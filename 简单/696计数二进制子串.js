
 /**
696.计数二进制子串
题目：给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。
重复出现的子串要计算它们出现的次数。

示例-1
    输入: "00110011"
    输出: 6
    解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。

    请注意，一些重复出现的子串要计算它们出现的次数。

    另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。


示例-2
    输入: "10101"
    输出: 4
    解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。
 */

 /**
 * @param {string} s
 * @return {number}
 */

/*
讲道理这道题我在解的时候苦苦思索没有思路，后来看了题目下的评论解题是真的牛啤。
1. 首先我们要明白一点的是，00110第一个子串是0011的话，就代表第一个0在后面就不用再被用到，也就是说函数的最外层其实就是个for循环，层层递进查找子串。
2. 如果知道00110中的第一个子串是0011呢，其实就是立一个变量cur记录当前记数，值为1，也就是代表一个数字的长度，如果[1]的数值和他前一位的数值[0]一样，就代表是00，cur++，（如果[2]和[1]一样，就代表是000，cur++）
3. 立一个变量last用于记录过去变量，如果循环到了001，[2]不等于[1]，last等于cur（2），cur重置，等于1。
4. 重点来了，如果last大于或者等于cur就让结果res变量++。这里是这个算法的精髓所在，目前我们走到了001这里，last是2，cur是1,虽然我们想找到的是0011，但是01不也是个子串吗？
5. [3]等于[2]都是1，cur是2了，last也是2，res再次+1，现在走到了0011，res是2，完全正确，如果0011111的话，last会一直是2，直到00111110的时候，last变成5。
 */

var s = "00110";
var countBinarySubstrings = function(s) {
    let last,
        cur,
        res;
    last = res = 0;
    cur = 1; 
        
    for(var i = 1; i<s.length ; i++){
        if(s[i] == s[i-1]){
            cur ++;
        }else{
            last = cur;
            cur = 1;
        }
        if(last>=cur) res++
    }

    return res;
};
countBinarySubstrings(s);