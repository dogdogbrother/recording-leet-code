/**
 * @param {number} n
 * @return {number[]}
 */
/**
 格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。
 给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。

 示例 1:
    输入: 2
    输出: [0,1,3,2]
    解释:
    00 - 0
    01 - 1
    11 - 3
    10 - 2

    对于给定的 n，其格雷编码序列并不唯一。
    例如，[0,2,3,1] 也是一个有效的格雷编码序列。

    00 - 0
    10 - 2
    11 - 3
    01 - 1

示例 2:
    输入: 0
    输出: [0]
    解释: 我们定义格雷编码序列必须以 0 开头。
         给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。
         因此，当 n = 0 时，其格雷编码序列为 [0]。

 */

/**
  
 这题看题都有点吃力，格雷编码到底是个什么东西，但是看了评论和解题，大概知道是什么意思了。
 例如我给一个数字3，3代表的是代表编码总位数，也就是000，然后我们要打印一个序列，序列中的每一位一定要和上一位不同，而且是只有一个位置的差异。
 000
 010
 011
 001
 101
 111
 110
 100

 难点就在于，如何每一层和上层比只有一次的差异，这也太难了吧，如果不看评论完全没有思路，看了评论才发现，其实还是有规律的，只是这个规律并不明显。


 有什么规律呢，我觉得有一种是比较好理解并且好实践的，就是镜像反射添加0和01，什么意思呢，我以长度为1的格林编码举例。
 00
 01
 11
 10
 我添加对应的四个镜像
 10
 11
 01
 00
 然后我在上面的镜像前面都+0，下面的镜像都+1，就会发现是上面的结果。

*/

/** 
 
 既然规律找到了，我应该怎么写这个函数呢。
 我觉得没有必要使用递归，循环就能完成。
 我们先定义结果，如果长度是0，就返回0，如果是1，就返回什么，我就是要求传进来需要计算的数值一定大于1.
 然后我定义1时的模板，循环从2开始就使用该模板进行编辑，

*/
var grayCode = function(n) {
    if(!n) return [0];
    if (n===1) return [0,1];
    //这两个都是边界处理
    let res = [0,1];   //存储结果的地方,也是模板数组(为n===1的模板)。
    for(let i = 2; i<=n; i++){
        let newArr = [...res];   
        newArr.reverse();   //经过这两步的操作，就有了一个镜像后的数组。
        res.forEach((item,index)=>{
            res[index] = '0' + item;    //遍历的时候分别在前面+0和+1
            newArr[index] = '1' + newArr[index] ;
        })
        res = res.concat(newArr)
    }
    res.forEach((item,index)=>{     
        res[index] = parseInt(item,2)   //转换下格式
    })
    return res;
};
console.log(grayCode(3));
